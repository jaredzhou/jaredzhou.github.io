<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Jared's Site</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="jared"><meta name=description content="Jared的个人博客"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.96.0"><link rel=canonical href=https://jaredzhou.github.io/><link href=/index.xml rel=alternate type=application/rss+xml title="Jared's Site"><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.f1e506a781bf25d33ffc18aa6b4e972a965c58049d27d4f92b7db2e9bf28e4bf.css integrity="sha256-8eUGp4G/JdM//Biqa06XKpZcWASdJ9T5K32y6b8o5L8=" media=screen crossorigin=anonymous><meta property="og:title" content="Jared's Site"><meta property="og:description" content="Jared的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://jaredzhou.github.io/"><meta itemprop=name content="Jared's Site"><meta itemprop=description content="Jared的个人博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="Jared's Site"><meta name=twitter:description content="Jared的个人博客"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Jared's Site</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://jaredzhou.github.io/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://jaredzhou.github.io/post/>Posts</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>Jared's Site</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://jaredzhou.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://jaredzhou.github.io/post/>Posts</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><section id=posts class=posts><article class="post bg-white"><header class=post-header><h1 class=post-title><a class=post-link href=/post/rust-references/>阅读Programming Rust第5章</a></h1><div class=post-meta><time datetime=2022-04-11 class=post-time>2022-04-11</time></div></header><div class=post-content><div class=post-summary><p>本文是对<a href=https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/>Programming Rust</a> 第5章的总结，部分代码与图片来自此书</p><h1 id=引用类型>引用类型</h1><p>rust有三种指针类型</p><ul><li><code>引用</code></li><li><code>裸指针</code></li><li><code>智能指针</code></li></ul><p>其中<code>引用</code>是一种非拥有指针，即不需要对<code>被引用对象</code>的生命周期负责，相反，<code>引用</code>的生命周期不能超过<code>被引用者</code>的生命周期</p><p>很多时候我们并不想转移值的所有权，仅仅需要访问值的某些数据，这个时候就需要使用<code>引用</code>了。</p><p>引用分为两种类型：</p><ul><li><code>共享引用</code> 可以读取<code>被引用对象</code>但是不能修改。同时可以存在多个<code>共享引用</code>，<code>共享引用</code>本身是<code>Copy</code>类型</li><li><code>可变引用</code>可以读取并且修改<code>被引用对象</code>，同时只能存在一个<code>可变引用</code>， 并且<code>可变引用</code>存在的时候， 不能存在任何共享引用，<code>可变引用</code>不是<code>Copy</code>类型</li></ul><p>需要说明的是， <code>可变引用</code>存在的时候， 不但是<code>共享引用不能存在</code>， <code>Owner</code>自己也不能访问和修改<code>被引用对象</code></p><h1 id=使用引用>使用引用</h1><p>以下是使用引用的一些示例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>//共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=o>*</span><span class=n>r</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//可变引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>y</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>m</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=o>*</span><span class=n>m</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>64</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=隐式解引用隐式借引用>隐式解引用/隐式借引用</h2><p>这里需要注意的是由于<code>解引用</code>，<code>借引用</code>是非常常见的操作，而且编码起来显得非常繁琐，所以rust对<code>.</code>操作符的左值做了<code>隐式解引用</code>与<code>隐式借引用</code>的操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>//隐式解引用， 接引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Anime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bechdel_pass</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>aria</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Anime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Aria: The Animation&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>bechdel_pass</span>: <span class=nc>true</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//隐式借引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>aria</span><span class=p>.</span><span class=n>print</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=o>&amp;</span><span class=n>aria</span><span class=p>).</span><span class=n>print</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>anime_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>aria</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//隐式解引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, {}!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>anime_ref</span><span class=p>.</span><span class=n>first_name</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, {}!&#34;</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>anime_ref</span><span class=p>).</span><span class=n>first_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=嵌套引用>嵌套引用</h2><p>rust中<code>引用</code>本身也是一个左值， 所以可以对引用再引用，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>1000</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>729</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span>: <span class=kp>&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>point</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rr</span>: <span class=kp>&amp;&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rrr</span>: <span class=kp>&amp;&amp;&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>rr</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//*操作符 循环解引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>rr0</span>:<span class=kp>&amp;&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>rrr</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r0</span>: <span class=kp>&amp;</span><span class=nc>Point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>rrr</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//.操作符循环解引用，直到到对应的值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>y</span>: <span class=mi>32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rrr</span><span class=p>.</span><span class=n>y</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>有个值得注意的点是在<a href=https://doc.rust-lang.org/book/ch15-02-deref.html>The book</a>中有一段是这么说的</p><blockquote><p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code</p></blockquote><p>上面的代码表面，对于引用，一个*操作符可以直接<code>解引用</code>到多个层级之上的类型。</p><p>我认为这是由于当我指定了类型之后， rust编译器会根据目标类型进行<code>Deref Coercion</code>, 我姑且叫它<code>强制类型转换</code>，<code>强制类型转</code>换会无限的将一个引用转成它可以转换到的引用，如果一个类型符合 <code>T: Deref&lt;Target=U></code></p><h2 id=引用比较计算>引用比较/计算</h2><p><code>引用比较</code>的是他们背后的值， 引用只能在相同类型直接做比较</p><p><code>引用运算</code>可以计算一层引用的背后的值， 多层引用则不能相加</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>ry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>y</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rrx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>rx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>ry</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rrx</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>rry</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rrx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert!</span><span class=p>(</span><span class=n>rx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>ry</span><span class=p>);</span><span class=w> </span><span class=c1>// their referents are equal 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>std</span>::<span class=n>ptr</span>::<span class=n>eq</span><span class=p>(</span><span class=n>rx</span><span class=p>,</span><span class=w> </span><span class=n>ry</span><span class=p>));</span><span class=w> </span><span class=c1>// but occupy different addresses
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//引用相加
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rx</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>ry</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=mi>20</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rrx</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rry</span><span class=p>;</span><span class=w> </span><span class=c1>//编译不通过， 这两个变量不能相加
</span></span></span></code></pre></td></tr></table></div></div><h2 id=胖指针>胖指针</h2><p>rust有两种常见的<code>胖指针</code></p><ul><li>对<code>slice</code>的引用, 额外包含length信息</li><li>对<code>trait object</code>的引用， 额外包含trait实现地址，即虚表</li></ul><p><code>胖指针</code>名字的来源是因为这种指针包含两个字长，一般的指针只包含一个。</p><p>指向<code>unszie type</code>的指针都是胖指针</p><h1 id=引用安全>引用安全</h1><p><code>引用</code>在rust中是内存安全的， 引用不会产生悬空指针的问题，rust通过<code>lifetime</code>来解决这个问题，以下这个段代码展示了违背生命周期的情况</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=c1>// bad: reads memory `x` used to occupy
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>​x在引用r之前被释放了， 这种情况是无法通过编译的, rust对于生命周期的限制如下：</p><p>假如我们有一个变量v的引用&v， 使变量r=&v， 我们必须满足</p><ol><li><p>变量v的生命周期必须包含&v的生命周期</p></li><li><p>&v的生命周期必须包含r的生命周期</p></li></ol><p>这两种情况任意一个不满足都会产生悬空指针。</p><p>在我看来r是v的一个引用，只需要满足v的生命周期包含r的生命周期即可</p><h2 id=引用作为函数入参>引用作为函数入参</h2><p>一个带<code>lifetime</code>的函数是这样子的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>f</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=kt>i32</span><span class=p>){}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里<code>f&lt;'a></code> &lsquo;a是作为函数的参数存在， 我们可以认为是 对于任意生命周期都适用，大部分情况下， 一个实参的周期是大于函数调用的。但是如果函数中存在这种情况，就不行了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>STASH</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=mi>128</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>f</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>STASH</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>P</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>STASH的生命周期是全局的， 而根据上面的规则2，p的生命周期必须包含&rsquo;static。显然对于任意生命周来说这是不满足的。这个时候只有将形参改成&rsquo;static才能满足这个条件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>f</span><span class=p>(</span><span class=n>p</span><span class=w> </span>:<span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>static</span> <span class=kt>i32</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>unsafe</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>STASH</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>P</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>以上的函数是正确的， 但是适用范围也更小了。</p><h2 id=引用作为函数返回>引用作为函数返回</h2><p>以下是一个返回引用的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>smallest</span><span class=p>(</span><span class=n>v</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>i32</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>for</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=o>*</span><span class=n>r</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=o>*</span><span class=n>s</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>我们忽略了生命周期， 当一个函数只有一个引用作为参数的时候，如果它的返回值包含引用， rust会认为它们有同样的生命周期。现在考虑以下的代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>parabola</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>9</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>9</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>smallest</span><span class=p>(</span><span class=o>&amp;</span><span class=n>parabola</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=o>*</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>根据上面的规则1，2， 必须满足parabola的生命周期必须大于s的生命周期， 这段代码中parabola要比s更早drop，所以是不能通过编译的</p><h2 id=结构体包含引用>结构体包含引用</h2><p>结构体必须包含生命周期参数，不然是无法通过编译的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>//含引用结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>S</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>r</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=kt>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//嵌套含引用结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>D</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>s</span>: <span class=nc>S</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=省略生命周期参数>省略<code>生命周期</code>参数</h2><p>省略生命周期有以下几种情况：</p><ul><li>函数不返回引用的情况下， 不需要显示指定<code>生命周期</code></li><li>如果函数只有一个参数，那么也不需要指定生命周期， 因为rust为认为任何返回引用的<code>生命周期</code>都与此参数相同</li><li>如果函数是一个类型的方法，并且形参是引用类型<code>self</code>(&self, &mut self)， rust会认为返回引用的<code>生命周期</code>与此相同</li></ul><h2 id=后续>后续</h2><p>rust的引用是一个根本又复杂的话题，这里还有很多东西没有讨论清楚， 比如<code>强制类型转换</code>， 比如<code>重借用</code>等等， 后续还需要进一步的研究</p></div></div></article><article class="post bg-white"><header class=post-header><h1 class=post-title><a class=post-link href=/post/rust-ownership-and-moves/>阅读Programming Rust第4章</a></h1><div class=post-meta><time datetime=2022-04-10 class=post-time>2022-04-10</time></div></header><div class=post-content><div class=post-summary><p>本文是对<a href=https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/>Programming Rust</a> 第4章的总结，部分代码与图片来自此书</p><h2 id=背景>背景</h2><p>我们通常希望变成语言提供以下特性：</p><ul><li>我们希望可以控制内存释放的时机</li><li>我们不希望使用一个对象已经被释放的指针</li></ul><p>c/c++与带gc的语言通过不同的机制解决以上问题，但是都各自有不同的缺点
rust使用了<code>Ownership</code>与<code>Borrow</code>来解决内存管理的问题</p><h2 id=ownership><code>Ownership</code></h2><ul><li>在rust中一个变量被赋值的时候就拥有了这个值的所有权，一个<code>Struct</code>拥有字段的所有权， 一个<code>Tuple</code>，<code>Array</code>，<code>Vec</code>拥有包含元素的所有权。</li><li>一个值只能被一个变量拥有， 这个变量会对此值的生命周期负责， 当一个变量被<code>Drop</code>的时候
它所拥有的所有值也会一起被销毁</li></ul><p>以下代码创建了一个<code>Vec</code>， 它包含了多个结构体</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>struct</span> <span class=nc>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>birth</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>composers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Palestrina&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>birth</span>: <span class=mi>1525</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Dowland&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>birth</span>: <span class=mi>1563</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>composers</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Person</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>name</span>: <span class=s>&#34;Lully&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>birth</span>: <span class=mi>1632</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>composer</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>&amp;</span><span class=n>composers</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}, born {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>composer</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>composer</span><span class=p>.</span><span class=n>birth</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>它的内存布局为
<img src=/owner.png alt></p><p>在很多情况下，这种一对一的绑定关系显然缺乏灵活性， 在真实的编程当中，对象之间的互相引用，多个对象引用同一个对象是很常见的(比如双向链表， 树结构等等)。所以rust在所有权原则的基础上提供很多其他机制来达成这种灵活性</p><h2 id=move><code>Move</code></h2><p>在rust中，像赋值，对函数传值，函数返回值等操作会使一个变量转移它对值得所有权，在一个变量转移所有权之后， 它会变成未初始化状态， 后续得代码无法访问该变量。比如以下代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;udon&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;ramen&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;soba&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在内存中的布局如下所示
<img src=/move.png alt></p><ul><li><code>s</code>在把值转移给t后变为未初始化状态，同时<code>t</code>只是对<code>s</code>的<code>值本身</code>(<code>Value Proper</code>)做了赋值。这里的<code>Value Proper</code>我理解的意思就是，大部分情况就是一个值的栈上数据， 因为栈上数据不需要做内存管理；当然肯定存在堆上数据做<code>Move</code>的情况，总的来说编译器会做一次浅复制</li><li><code>Move</code>操作保证了一个值始终只有一个拥有者，所以有且只有一个人会对这个值的内存管理负责</li></ul><h3 id=控制流中的move>控制流中的<code>Move</code></h3><p>rust编译器会根据条件语句来判断，一个值是否被<code>Move</code>，比如</p><p>if/else语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, move&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>  </span><span class=c1>//这个move允许
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>g</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>  </span><span class=c1>//这个move也允许
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>h</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w> </span><span class=c1>//这里无论哪种情况move都已经发生
</span></span></span></code></pre></td></tr></table></div></div><p>循环语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, move&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>g</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>  </span><span class=c1>//这里编译不会通过，因为x会再第一次move的时候失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=数组中的move>数组中的<code>Move</code></h3><p>一个<code>Vec</code> <code>V</code>中的元素属于<code>V</code>, 不能将他<code>Move</code>给其他变量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// Build a vector of the strings &#34;101&#34;, &#34;102&#34;, ... &#34;105&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>101</span><span class=o>..</span><span class=mi>106</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// Pull out random elements from the vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>third</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span><span class=w> </span><span class=c1>// error: Cannot move out of index of Vec let fifth = v[4]; // here too
</span></span></span></code></pre></td></tr></table></div></div><ul><li>当然了一个<code>Vec</code>必须可以删除元素， 比如移除队尾数据， 移除数据并且使用队尾填充， 还有著名的<code>mem::replace</code>, 这些方法都遵循一个原则就是保证vec在一个连贯的状态,使得<code>Vec</code>只在记录<code>length</code>的情况下就能维护本身的状态。
由于对外赋值会导致<code>Move</code>， 所以一般赋值操作可以使用<code>Borrow</code>或者<code>Clone</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Build a vector of the strings &#34;101&#34;, &#34;102&#34;, ... &#34;105&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>101</span><span class=o>..</span><span class=mi>106</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 1. Pop a value off the end of the vector:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>fifth</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>pop</span><span class=p>().</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;vector empty!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>fifth</span><span class=p>,</span><span class=w> </span><span class=s>&#34;105&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 2. Move a value out of a given index in the vector,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// and move the last element into its spot:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>second</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>swap_remove</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>second</span><span class=p>,</span><span class=w> </span><span class=s>&#34;102&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 3. Swap in another value for the one we&#39;re taking out:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>third</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>replace</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span><span class=w> </span><span class=s>&#34;substitute&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>third</span><span class=p>,</span><span class=w> </span><span class=s>&#34;103&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// Let&#39;s see what&#39;s left of our vector.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;101&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;104&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;substitute&#34;</span><span class=p>]);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>值得一提的是 ，一个<code>Vec</code>使用<code>remove</code>方法删除index处的元素时， 所有右边的元素都会左移，这个操作消耗是很大的。不过这个东西跟rust无关， 所有语言都是这么实现</p></li><li><p>另外在一个for循环中， 我们会将整个<code>Vec</code>转移出去， 并且将他打散成各个元素， 后续不管这些元素有没有被再次转移， 整个初始<code>Vec</code>已经不可见了</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;a&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;b&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;c&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>{</span><span class=w>          </span><span class=c1>//move the entire v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;b&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span><span class=w>  </span><span class=c1>//v is moved, 编译不通过
</span></span></span></code></pre></td></tr></table></div></div><h2 id=copy>Copy</h2><p>在rust中对于简单类型，也使用<code>Move</code>语义是没有必要的, 因为简单类型除了自己的<code>值本身</code>之外并没有要额外管理的资源，这个资源可能是堆内存，可能是文件句柄等。这个时候对一个变量赋值应该是直接<code>Copy</code>就可以了， 事实上他跟<code>Move</code>就仅仅是是否清除原变量的<code>值本身</code>，原变量是否保持可用</p><p><code>Copy</code>类型包含了</p><ul><li>整数，浮点，字符，布尔，指针等</li><li><code>Copy</code>类型组成的<code>Tuple</code></li><li><code>Copy</code>类型组成的<code>Array</code></li><li>指定了<code>Copy</code>的<code>Struct</code></li><li>指定了<code>Copy</code>的枚举</li><li>所有复制只需要位拷贝的类型</li></ul><p>不包含</p><ul><li>所有<code>Drop</code>的时候需要额外处理的都不是<code>Copy</code>类型</li><li>默认的`Struct</li><li>默认的<code>Enum</code></li></ul><h2 id=rc和arc><code>Rc</code>和<code>Arc</code></h2><p>有了<code>Move</code>跟<code>Copy</code>之后，值的使用仍然比较受限， 很多时候我们希望可以有多个变量持有同一个值，就像其他语言一样。这个时候<code>Rc</code>就派上用场了，一个Rc就是在遵循前面几种规则的基础上，创造出的一种引用计数类型。</p><ul><li>按照<code>Ownership</code>的原则， 是不允许多个变量同时持有一个值<code>T</code>的。那么怎么做呢？答案就是把值<code>T</code>包装到一个容器里， 容器本身遵循<code>Ownership</code>, 容器内部来决定何时drop关联的值<code>T</code>, 这里这个容器就是Rc.</li><li><code>Rc</code>的共享使用<code>Clone</code>来实现, <code>Clone</code>操作只是对引用计数+1， 当变量被<code>Drop</code>时引用技术-1，当引用技术变为0的时候， Rc所包装的值<code>T</code>被释放</li><li><code>Rc</code>所包装的值<code>T</code>是不可变的， 这个符合<code>单个可变</code>与<code>多个共享</code>之间的排斥性,某些情况下可以使用内部可变性容器来解决这个问题， 比如<code>Cell</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>s</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;shirataki&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>t</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>u</span>: <span class=nc>Rc</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>以下是Rc的内存布局
<img src=/rc.png alt></p></div></div></article><article class="post bg-white"><header class=post-header><h1 class=post-title><a class=post-link href=/post/ruststr/>Rust string type</a></h1><div class=post-meta><time datetime=2022-04-08 class=post-time>2022-04-08</time></div></header><div class=post-content><div class=post-summary><h3 id=string和str>string和&str</h3><p>rust中操作字符串比较常用的是<code>String</code>和<code>&str</code> 比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, world&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//以下三种都为&amp;str类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello, world&#34;</span><span class=p>;</span><span class=w>        </span><span class=c1>//字面常量 string literal， 存储在常量区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>hello</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>string</span><span class=p>[</span><span class=o>..</span><span class=mi>5</span><span class=p>];</span><span class=w>      </span><span class=c1>//从string中得到&amp;str
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>world</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>6</span><span class=o>..</span><span class=p>];</span><span class=w>          </span><span class=c1>//从&amp;str中得到&amp;str
</span></span></span></code></pre></td></tr></table></div></div><h4 id=内存布局>内存布局</h4><p>以下是<code>String</code>与<code>&str</code>在内存中的结构，<code>String</code>占用了3个字长，<code>&str</code>占用两个字长。他们都有一个指向底层数组的指针。</p><p><img src=/str.png alt></p><h4 id=实现源码>实现源码</h4><p>string的内部实现就是一个Vec[u8]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>vec</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>vec本身的实现如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=cp>#[unstable(feature = </span><span class=s>&#34;allocator_api&#34;</span><span class=cp>, issue = </span><span class=s>&#34;32838&#34;</span><span class=cp>)]</span><span class=w> </span><span class=n>A</span>: <span class=nc>Allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Global</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>buf</span>: <span class=nc>RawVec</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>len</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>struct</span> <span class=nc>RawVec</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>A</span>: <span class=nc>Allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Global</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>ptr</span>: <span class=nc>Unique</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>cap</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>alloc</span>: <span class=nc>A</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>以上可以看出string的内存占用从何而来</p><p><code>str</code>是一个原生类型，字面常量的完整类型是<code>&‘static str</code>, 虽然没有<code>str</code>的类型定义，但是从它的方法中也可以找到它的内部结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>story</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Once upon a time...&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>ptr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>story</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>story</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// story has nineteen bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>19</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// We can re-build a str out of ptr and len. This is all unsafe because
</span></span></span><span class=line><span class=cl><span class=c1>// we are responsible for making sure the two components are valid:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// First, we build a &amp;[u8]...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>slice</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>slice</span>::<span class=n>from_raw_parts</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... and then convert that slice into a string slice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kt>str</span>::<span class=n>from_utf8</span><span class=p>(</span><span class=n>slice</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>story</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=str的其他使用方式>str的其他使用方式</h3><p>理论上可以通过各种方式得到<code>str</code>类型本身，然而编译器并不能通过， 主要是因为<code>str</code>类型为unsize type， 并不能够在栈中存在。比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, world&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello, world&#34;</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//以下三个变量都为str类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>ss</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>string</span><span class=p>[</span><span class=o>..</span><span class=mi>5</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>[</span><span class=mi>6</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=boxstr><code>Box&lt;str></code></h4><p>既然<code>str</code>不能在栈上存在，那么能不能显式放到堆上呢？答案是可以的,那就是<code>Box&lt;str></code>，但是<code>Box&lt;str></code>只能通过以下一种方式初始化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello, world&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//除了&amp;str,你还可以使用Box&lt;str&gt;,下面是可以创建Box&lt;str&gt;的唯一方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>box_s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>string</span><span class=p>.</span><span class=n>into_boxed_str</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>Box&lt;str></code>同样是占用2个字长，事实上，当一个<code>unsize type</code>被放在引用或者指针后面的时候它就是一个2字长胖指针，比如<code>&[u8]</code>, <code>&dyn Trait</code>都是如此， <code>*const [T]</code>也是一样</p><h4 id=cowstr><code>Cow&lt;str></code></h4><p>很多时候，我们希望函数接口保持兼容性与灵活性，通常使用<code>&str</code>而不是<code>String</code>或者·<code>&String</code>作为接口，但是作为返回，如果这个函数并没有修改这个<code>&str</code>,那么我们希望可以直接返回它， 但是当这个函数改变了值，我们只能复制这个<code>str</code>并且返回<code>String</code>类型以获得owned值。这个时候<code>Cow&lt;str></code>就派上了用场。以下是定义</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Cow</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>B</span>: <span class=o>&#39;</span><span class=na>a</span> <span class=o>+</span><span class=w> </span><span class=nb>ToOwned</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>?</span><span class=nb>Sized</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Borrowed</span><span class=p>(</span><span class=o>&amp;&#39;</span><span class=na>a</span><span class=w> </span><span class=n>B</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Owned</span><span class=p>(</span><span class=o>&lt;</span><span class=n>B</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nb>ToOwned</span><span class=o>&gt;</span>::<span class=n>Owned</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li>标准库中，对于<code>Cow&lt;str></code>的使用有<a href=https://doc.rust-lang.org/stable/std/string/struct.String.html#method.from_utf8_lossy>from_utf8_lossy</a>返回<code>&str</code></li></ol><ul><li>不需要分配新的内存</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// some bytes, in a vector
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>sparkle_heart</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>240</span><span class=p>,</span><span class=w> </span><span class=mi>159</span><span class=p>,</span><span class=w> </span><span class=mi>146</span><span class=p>,</span><span class=w> </span><span class=mi>150</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>sparkle_heart</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from_utf8_lossy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sparkle_heart</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=s>&#34;💖&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sparkle_heart</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>返回<code>String</code>, 由于修改了字符串内容， 重新复制了内存</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// some invalid bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>b&#34;Hello </span><span class=se>\xF0\x90\x80</span><span class=s>World&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from_utf8_lossy</span><span class=p>(</span><span class=n>input</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=s>&#34;Hello �World&#34;</span><span class=p>,</span><span class=w> </span><span class=n>output</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>在crate <code>regex</code>中有一个replace方法，同样使用<code>Cow&lt;str></code>作为返回值</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w> </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>replace_all</span><span class=o>&lt;&#39;</span><span class=na>t</span><span class=p>,</span><span class=w> </span><span class=n>R</span>: <span class=nc>Replacer</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>text</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>t</span> <span class=kt>str</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>rep</span>: <span class=nc>R</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Cow</span><span class=o>&lt;&#39;</span><span class=na>t</span><span class=p>,</span><span class=w> </span><span class=kt>str</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>replacen</span><span class=p>(</span><span class=n>text</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>rep</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>我们可以直接使用<code>Cow&lt;str></code>， 打印或者写入文件</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>//new 一个正则表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>regex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Regex</span>::<span class=n>new</span><span class=p>(</span><span class=n>target</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//返回一个Cow&lt;str&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>cow</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>regex</span><span class=p>.</span><span class=n>replace_all</span><span class=p>(</span><span class=n>text</span><span class=p>,</span><span class=w> </span><span class=n>replacement</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//打印字符串
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=s>&#34;str is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>cow</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//输出到文件, 这个需要注意&amp;*cow得到&amp;str类型
</span></span></span><span class=line><span class=cl><span class=c1>// &amp;(*cow.deref())
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fs</span>::<span class=n>write</span><span class=p>(</span><span class=s>&#34;output.txt&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;*</span><span class=n>cow</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></div></div></article></section><nav class=pagination><ul><li class=active><a href=/>1</a></li><li><a href=/page/2/>2</a></li></ul></nav></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:zhouzhenyu1313@163.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=https://github.com/jaredzhou rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://jaredzhou.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2021 -
2022
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>jared</span></span>
<span id=busuanzi_container>访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></body></html>